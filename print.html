<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Wasefire</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="overview/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/terminology.html"><strong aria-hidden="true">1.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="overview/features.html"><strong aria-hidden="true">1.2.</strong> Features</a></li></ol></li><li class="chapter-item expanded "><a href="quick/index.html"><strong aria-hidden="true">2.</strong> Quick start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quick/codespace.html"><strong aria-hidden="true">2.1.</strong> Github codespace tips</a></li></ol></li><li class="chapter-item expanded "><a href="applet/index.html"><strong aria-hidden="true">3.</strong> Applet user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="applet/create.html"><strong aria-hidden="true">3.1.</strong> Create a new applet</a></li><li class="chapter-item expanded "><a href="applet/run.html"><strong aria-hidden="true">3.2.</strong> Run an applet</a></li><li class="chapter-item expanded "><a href="applet/api.html"><strong aria-hidden="true">3.3.</strong> API</a></li><li class="chapter-item expanded "><a href="applet/prelude/index.html"><strong aria-hidden="true">3.4.</strong> Prelude</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="applet/prelude/led.html"><strong aria-hidden="true">3.4.1.</strong> LEDs</a></li><li class="chapter-item expanded "><a href="applet/prelude/button.html"><strong aria-hidden="true">3.4.2.</strong> Buttons</a></li><li class="chapter-item expanded "><a href="applet/prelude/timer.html"><strong aria-hidden="true">3.4.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="applet/prelude/usb.html"><strong aria-hidden="true">3.4.4.</strong> USB</a></li><li class="chapter-item expanded "><a href="applet/prelude/uart.html"><strong aria-hidden="true">3.4.5.</strong> UART</a></li><li class="chapter-item expanded "><a href="applet/prelude/store.html"><strong aria-hidden="true">3.4.6.</strong> Storage</a></li></ol></li><li class="chapter-item expanded "><a href="applet/exercises/index.html"><strong aria-hidden="true">3.5.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="applet/examples.html"><strong aria-hidden="true">3.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="runner/index.html"><strong aria-hidden="true">4.</strong> Runner user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runner/api.html"><strong aria-hidden="true">4.1.</strong> API</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Developer guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Design</div></li></ol></li><li class="chapter-item expanded "><a href="faq.html">FAQ</a></li><li class="chapter-item expanded affix "><a href="links.html">Links</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">Acknowledgments</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wasefire</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/wasefire/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction"><a href="https://google.github.io/wasefire">Introduction</a></a></h1>
<p>This book is a walk through the <em>Wasefire</em> project.</p>
<h2 id="vision"><a class="header" href="#vision">Vision</a></h2>
<blockquote>
<p>Provide a <strong>simple-to-use</strong> and <strong>secure-by-default</strong> ecosystem for firmware development.</p>
</blockquote>
<h3 id="simple-to-use"><a class="header" href="#simple-to-use">Simple-to-use</a></h3>
<p>The ecosystem aspires to be accessible to projects and developers regardless of their familiarity
with developing secure firmware:</p>
<ul>
<li>No embedded expertise required: Regular software engineers can develop firmware.</li>
<li>No security expertise required: The ecosystem provides secure-by-default options.</li>
<li>No enforced programming language: Developers may use the language of their choice, as long as it
compiles to WebAssembly or the target architecture.</li>
<li>No enforced development environment or build system: Developers may use their usual setup.</li>
</ul>
<h3 id="secure-by-default"><a class="header" href="#secure-by-default">Secure-by-default</a></h3>
<p>Security is the responsibility of the ecosystem, not the developer. The following security
mechanisms are (or are planned to be) in place:</p>
<ul>
<li>Sandboxing of the firmware functions (called applets) from each other and from the firmware
runtime (called platform).</li>
<li>Secure implementation within the platform boundaries (e.g. side-channel resistance, fault
injection protection, etc).</li>
<li>Security reviews for the supported boards (e.g. side-channel attacks, fault injection, etc).</li>
<li>User documentation when the security must rely on user behavior, for example when a configuration
is insecure.</li>
</ul>
<p>Even though the default is to be secure, the ecosystem will provide options to opt-out from some of
the security features for performance or footprint reasons. In other words, the developer is able to
choose the trade-off between security and performance, defaulting to security without explicit
action.</p>
<h3 id="symbiosis"><a class="header" href="#symbiosis">Symbiosis</a></h3>
<p>Being both simple-to-use and secure-by-default actually goes hand in hand. It cannot be expected for
humans to never do mistake, even if they have embedded and security expertise.</p>
<ul>
<li>By being simple to use, developers will prefer using the ecosystem solution rather than
implementing their own, thus using a secure-by-default solution rather than a possibly insecure
implementation.</li>
<li>By not being concerned with security and embedded details, developers can be more productive and
focus on the actual firmware behavior, following the well-lit path for all security and embedded
questions.</li>
</ul>
<h2 id="non-goals"><a class="header" href="#non-goals">Non-goals</a></h2>
<p>The project is not trying to build a self-service applet store. In particular, users are developers.
A self-service applet store may come at a later phase or may be done independently by another
project. The project will provide anything needed for such applet store to be secure and easy to
use.</p>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>The project is still work in progress and many components might change in the future. However, the
project follows the usual <a href="https://doc.rust-lang.org/cargo/reference/semver.html">Rust semantic
versioning</a> to avoid unexpected breakages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This chapter gives a high-level overview of the project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<p>The project is split in the following components:</p>
<ul>
<li>A <em>Device</em> is a final product.</li>
<li>A <em>User</em> is a person, team, or organization owning the Device.</li>
<li>A <em>Board</em> is the hardware of the Device.</li>
<li>An <em>Applet</em> is part of the software of the Device.</li>
<li>The <em>Board API</em> is the hardware abstraction layer.</li>
<li>The <em>Applet API</em> is the platform abstraction layer.</li>
<li>A <em>Prelude</em> is a library providing language-specific access to the Applet API.</li>
<li>A <em>Runner</em> is a binary implementing the Board API and running the Scheduler.</li>
<li>The <em>Scheduler</em> is the software implementing all the platform logic and fits
between the Board API and the Applet API.</li>
<li>A <em>Platform</em> is the binary made of a Runner and the Scheduler.</li>
</ul>
<h2 id="device"><a class="header" href="#device">Device</a></h2>
<p>A Device encompasses the following (non-exhaustive list):</p>
<ul>
<li>A hardware on which to run (chip, form factor, external devices, etc).</li>
<li>How this hardware is configured and initially provisioned.</li>
<li>A set of applets defining the firmware, and their configuration.</li>
<li>What is the funtionality expected from the firmware.</li>
<li>Should the Device be certified.</li>
<li>Where will the Device be installed.</li>
<li>Who will/should have access to the Device.</li>
</ul>
<h2 id="user"><a class="header" href="#user">User</a></h2>
<p>Users may delegate part of the Device design to other teams:</p>
<ul>
<li>Developing hardware or selecting an existing hardware.</li>
<li>Developing one or more applets and/or selecting one or more applets.</li>
<li>Design of the functionality.</li>
<li>Lifetime management (provisioning, logging, monitoring, alerting, census,
etc).</li>
</ul>
<p>Users are responsible for all those steps. The project will however support them
in those tasks for both development and security aspects. For example
(non-exhaustive list):</p>
<ul>
<li>The platform provides unique ids per device.</li>
<li>The platform supports secure updates.</li>
<li>The platform provides applet management (with versioning).</li>
<li>The platform supports some existing hardware (may add support for more based
on demand).</li>
</ul>
<h2 id="board"><a class="header" href="#board">Board</a></h2>
<p>The project provides support for some boards through Runners. Additional boards
may be supported depending on User needs.</p>
<p>Boards may be subject to some restrictions:</p>
<ul>
<li>Only ARM Cortex-M and RISC-V architectures are considered for now.</li>
<li>Minimum flash and RAM requirements (to be defined).</li>
</ul>
<h2 id="applet"><a class="header" href="#applet">Applet</a></h2>
<p>The functionality (or business logic) of a Device is implemented as a set of
concurrent applets. The project provides example applets in the different
supported languages for the User to use as starting point. Eventually, an applet
is compilet into WebAssembly which is the only language that the Scheduler
supports.</p>
<h2 id="board-api"><a class="header" href="#board-api">Board API</a></h2>
<p>The Board API may be partially implemented for 2 reasons:</p>
<ul>
<li>The Board doesn't support some features in hardware and a software
implementation is not feasible or desired.</li>
<li>The User knows that those features are not going to be used by any applets
that will run on the Device. And the space saved by not implementing or
building them is needed for the Device to properly function.</li>
</ul>
<h2 id="applet-api"><a class="header" href="#applet-api">Applet API</a></h2>
<p>The Applet API is currently the same as (or very close to) the Board API. This
may change in the future, for example if capabilities require it. The Board API
is low-level and doesn't have a notion of capabilities. It fully trusts the
Scheduler. The Applet API on the other hand may need to prove to the Scheduler
that it is allowed to access some dynamically-allocated resource.</p>
<p>The Board API and the Applet API provide portability of Applets across different
Boards.</p>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>The Applet API is defined at the WebAssembly level. Applet developers may use it
directly, but depending on the language this usage may not be convenient. For
example, in Rust, using the Applet API requires the <code>unsafe</code> keyword and thus
some good understanding of what's going on. For such languages, a Prelude is
provided to give a simpler and more natural interface to the Applet API. For
example, in Rust, the Prelude provides a safe API with high-level Rust-specific
types like <code>&amp;[u8]</code> (instead of the <code>u32</code> pointer and <code>u32</code> length that the
Applet API expects).</p>
<h2 id="runner"><a class="header" href="#runner">Runner</a></h2>
<p>The project provides Runners for supported Boards. However, Board support
doesn't need to be provided by the project. The User (for example the team
developing the Board) may develop its own Runner for its own Board. Simplifying
the development of Runners (by maximizing the code shared with other Runners) is
part of the project vision. The project simplifies development of both Runners
and Applets, not just Applets.</p>
<h2 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h2>
<p>Together with the Board API and the Applet API, the Scheduler is the core
contribution of the project and where most security properties are implemented.
This is completely provided by the project and Users cannot alter it. However,
they can configure it when configuring a Platform.</p>
<h2 id="platform"><a class="header" href="#platform">Platform</a></h2>
<p>This is the firmware that runs on the Device. It doesn't provide any business
logic, but provides some core functionalities like (non-exhaustive list):</p>
<ul>
<li>Secure updates.</li>
<li>Applet management.</li>
<li>Debugging facilities.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>Features are implemented if their checkbox is checked.</p>
<p>If a feature is not implemented, it doesn't mean it will get implemented.
It means this is a feature that could be implemented if there is a user need.</p>
<p>If a feature is not listed, it doesn't mean it won't get implemented. We may
just not be aware of it, and a user need could justify an implementation.</p>
<h2 id="supported-boards"><a class="header" href="#supported-boards">Supported boards</a></h2>
<p>A board is supported if it has a Runner.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Linux (for testing without hardware)</li>
<li><input disabled="" type="checkbox" checked=""/>
nRF52840</li>
<li><input disabled="" type="checkbox"/>
OpenTitan</li>
</ul>
<h2 id="supported-applet-languages"><a class="header" href="#supported-applet-languages">Supported applet languages</a></h2>
<p>An applet language is supported if it has a Prelude.</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Rust</li>
<li><input disabled="" type="checkbox"/>
C</li>
</ul>
<p>Note that when running multiple applets concurrently on the same platform, those
applets don't need to be written in the same language to inter-operate.</p>
<h2 id="developer-experience"><a class="header" href="#developer-experience">Developer experience</a></h2>
<h3 id="for-applets"><a class="header" href="#for-applets">For applets</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Development doesn't require hardware (using the Linux board).</li>
<li><input disabled="" type="checkbox"/>
Testing facilities (probably on any board).</li>
<li><input disabled="" type="checkbox"/>
Fuzzing facilities (probably on Linux board only).</li>
<li><input disabled="" type="checkbox"/>
Rich debugger experience (probably on any board).</li>
</ul>
<h3 id="for-runners"><a class="header" href="#for-runners">For runners</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Testing facilities (probably a set of test applets).</li>
</ul>
<h2 id="reproducible-builds"><a class="header" href="#reproducible-builds">Reproducible builds</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Hermetic development environment for applets.</li>
<li><input disabled="" type="checkbox"/>
Hermetic development environment for platforms.</li>
</ul>
<h2 id="secure-platform-upgrades"><a class="header" href="#secure-platform-upgrades">Secure platform upgrades</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
The platform can be upgraded.</li>
<li><input disabled="" type="checkbox"/>
The platform can be downgraded to the extent permitted by the
User-configured rollback policy.</li>
<li><input disabled="" type="checkbox"/>
Platform upgrades are digitally signed and verified.</li>
</ul>
<h2 id="applet-sandboxing"><a class="header" href="#applet-sandboxing">Applet sandboxing</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Applets can't tamper with the platform.</li>
<li><input disabled="" type="checkbox"/>
Applets can't tamper with other applets (this is only missing preemptive
concurrency).</li>
</ul>
<h2 id="applet-capabilities"><a class="header" href="#applet-capabilities">Applet capabilities</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Applets declare their permissions (i.e. function imports).</li>
<li><input disabled="" type="checkbox"/>
Applets declare their capabilities (more dynamic concept of permission).</li>
<li><input disabled="" type="checkbox"/>
Applets metadata (or manifest) is signed.</li>
</ul>
<h2 id="platform-side-channel-attack-testing-and-resistance"><a class="header" href="#platform-side-channel-attack-testing-and-resistance">Platform side-channel attack testing and resistance</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Crypto hardware accelerators are leveraged when available.
<ul>
<li><input disabled="" type="checkbox" checked=""/>
AES CCM (Bluetooth spec) on nRF52840</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
Otherwise fallback software crypto primitives are provided for main
algorithms.</li>
<li><input disabled="" type="checkbox"/>
Both of those implementations are side-channel attack resilient.</li>
</ul>
<h2 id="applet-portability"><a class="header" href="#applet-portability">Applet portability</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Applets are portable at binary level (comes from Wasm and APIs).</li>
</ul>
<h2 id="applet-multiplexing"><a class="header" href="#applet-multiplexing">Applet multiplexing</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Multiple applets may be installed at the same time.</li>
<li><input disabled="" type="checkbox"/>
Multiple applets may run simultaneously (not in early versions).</li>
<li><input disabled="" type="checkbox"/>
Applets can be installed without running.</li>
<li><input disabled="" type="checkbox"/>
Applets define in their metadata their running condition (e.g. at boot, at
USB, at idle, etc).</li>
</ul>
<p>For now, a single applet is baked at compile-time in the platform.</p>
<h2 id="applet-management"><a class="header" href="#applet-management">Applet management</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Applets are identified by a stable id, a version, and a digital signature
(verified by the runtime).</li>
<li><input disabled="" type="checkbox"/>
Applets may be installed if not already present.</li>
<li><input disabled="" type="checkbox"/>
Applets may be uninstalled in which case all owned resources are deleted.</li>
<li><input disabled="" type="checkbox"/>
Applets may be upgraded (preserving resources) but not downgraded
(probably modulo rollback policy).</li>
<li><input disabled="" type="checkbox"/>
Installed applets can be listed.</li>
</ul>
<h2 id="certification"><a class="header" href="#certification">Certification</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
The runtime can run on certified hardware (FIPS-140-3 and CC).</li>
<li><input disabled="" type="checkbox"/>
TBD: The runtime might sustain being part of the security target for
certification.</li>
</ul>
<h2 id="low-power"><a class="header" href="#low-power">Low power</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
If the runtime is only waiting on external hardware events, the CPU is
suspended.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h1>
<p>Please open an <a href="https://github.com/google/wasefire/issues/new">issue</a> if a step
doesn't work.</p>
<h2 id="repository-setup"><a class="header" href="#repository-setup">Repository setup</a></h2>
<h3 id="local-machine"><a class="header" href="#local-machine">Local machine</a></h3>
<p>Clone the repository and run the setup script<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><code class="language-shell">git clone https://github.com/google/wasefire
cd wasefire
./scripts/setup.sh
</code></pre>
<h3 id="github-codespace"><a class="header" href="#github-codespace">Github codespace</a></h3>
<ul>
<li>Open <a href="https://codespaces.new/google/wasefire?quickstart=1">https://codespaces.new/google/wasefire?quickstart=1</a></li>
<li>Click the green <code>Create new codespace</code> (or <code>Resume this codespace</code>) button</li>
<li>Wait 2 minutes for the codespace to be created (or a 10 seconds to be resumed)</li>
</ul>
<h2 id="run-an-applet"><a class="header" href="#run-an-applet">Run an applet</a></h2>
<p>Depending on your hardware, you can run the hello applet with:</p>
<ul>
<li><code>cargo xtask applet rust hello runner nordic</code> to run on an nRF52840 dev-kit.</li>
<li><code>cargo xtask applet rust hello runner host</code> to run on your desktop.</li>
<li><code>cargo xtask applet rust hello runner host --web</code> to run on your desktop with
a web UI.</li>
</ul>
<p>The general format is <code>cargo xtask applet LANGUAGE NAME runner BOARD</code>. Example
applets are listed in the <code>examples</code> directory by <em>language</em> then <em>name</em>.
<em>Boards</em> are listed under the <code>crates</code> directory and are prefixed by <code>runner-</code>.
You can find more details using <code>cargo xtask help</code>.</p>
<p>Feel free to stop and play around by directly editing the examples. Or continue
reading for a deeper tutorial on how to write applets in Rust.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The setup script is best effort and is only meant for Unix systems so far.
On Debian-based Linux systems, the script will directly invoke installation
commands, possibly asking for sudo password. On other systems, the script
will return an error and print a message each time a binary or library must
be installed. Once the package is installed, the script must be run again.
The script will eventually print nothing and return a success code
indicating that no manual step is required and everything seems in order.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github-codespace-tips"><a class="header" href="#github-codespace-tips">Github codespace tips</a></h1>
<h2 id="editing-an-applet"><a class="header" href="#editing-an-applet">Editing an applet</a></h2>
<p>For rust-analyzer to work properly, you need to open the applet in its own
workspace, for example:</p>
<pre><code class="language-shell">code examples/rust/exercises/part-1
</code></pre>
<p>However, this will also modify the working directory of the terminal. To be able
to run <code>cargo xtask</code>, you will need to go back to the root of the git
repository:</p>
<pre><code class="language-shell">cd /workspaces/wasefire
</code></pre>
<p>You can then open the <code>src/lib.rs</code> file and benefit from documentation (hovering
a name), auto-completion, diagnostics, and other rust-analyzer features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applet-user-guide"><a class="header" href="#applet-user-guide">Applet user guide</a></h1>
<p>This chapter describes all you need to know to write an applet. Because we
currently only support Rust for writing applets, this guide only describes Rust
usage.</p>
<p>You need to have set the repository up according to the <a href="applet/../quick/index.html">quick
start</a> instructions to be able to continue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-new-applet"><a class="header" href="#create-a-new-applet">Create a new applet</a></h1>
<p>This step will <a href="https://github.com/google/wasefire/issues/38">eventually</a> be a
simple <code>wasefire new &lt;applet-name&gt;</code> command out of tree. But for now we will
build the applet within the project repository as an example applet. We'll use
<code>tutorial</code> as the applet name throughout this tutorial.</p>
<p>You have 2 options to create and populate the applet directory. We'll go over
both for pedagogical reasons.</p>
<h2 id="copy-the-hello-applet"><a class="header" href="#copy-the-hello-applet">Copy the <code>hello</code> applet</a></h2>
<p>The first step is to copy the <code>hello</code> directory to the <code>tutorial</code> directory:</p>
<pre><code class="language-shell">cp -r examples/rust/hello examples/rust/tutorial
</code></pre>
<p>The second step is to update the applet name in the <code>Cargo.toml</code>:</p>
<pre><code class="language-shell">sed -i 's/hello/tutorial/' examples/rust/tutorial/Cargo.toml
</code></pre>
<h2 id="create-the-applet-from-scratch"><a class="header" href="#create-the-applet-from-scratch">Create the applet from scratch</a></h2>
<p>Create the <code>tutorial</code> directory:</p>
<pre><code class="language-shell">mkdir examples/rust/tutorial
</code></pre>
<p>Create the <code>Cargo.toml</code> file in the created directory with the following
content:</p>
<pre><code class="language-toml">[package]
name = &quot;tutorial&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
wasefire = &quot;*&quot; # use the latest version
</code></pre>
<p>The <code>wasefire</code> dependency provides a high-level interface to the Applet API.</p>
<p>Then create the <code>src/lib.rs</code> file in the created directory with the following
content:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std] // needed for building wasm (without wasi)
wasefire::applet!(); // imports the prelude and defines main as entry point

fn main() {
    debug!(&quot;hello world&quot;);
}</code></pre></pre>
<p>Note that because you need to use <code>core</code> or <code>alloc</code> instead of <code>std</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-an-applet-1"><a class="header" href="#run-an-applet-1">Run an applet</a></h1>
<p>We currently use <code>cargo xtask</code> as an alias to the local <code>xtask</code> crate to build,
flash, and run platforms and applets. Eventually, this will be a <code>wasefire</code>
command and will work out-of-tree. You can use <code>cargo xtask help</code> to discover
the tool.</p>
<h2 id="on-host"><a class="header" href="#on-host">On host</a></h2>
<p>We can run an applet (here the <code>tutorial</code> applet) on the <code>host</code> runner with the
following command:</p>
<pre><code class="language-shell">cargo xtask applet rust tutorial runner host
</code></pre>
<p>Type your password when asked. The <code>host</code> runner needs <code>sudo</code> to set USB/IP up,
which is needed for applets that use USB. This is disabled in Github Codespace.
After a bunch of compilation steps, you should see something that ends like:</p>
<pre><code class="language-plaintext">     Running `.../wasefire/target/release/runner-host`
Executing: sudo modprobe vhci-hcd
[sudo] password for user:
Executing: sudo usbip attach -r localhost -b 1-1
Board initialized. Starting scheduler.
00000.000: hello world
</code></pre>
<p>The first line is output by <code>cargo</code>. The last 2 lines are output by the host
runner. The last one was triggered by the applet. Debugging output is prefixed
with a timestamp.</p>
<p>The host runner (like all runners) doesn't stop, even if all applets have
completed. Instead, it goes to sleep. This is because all known use-cases are
reactor-like (they react to external input). Besides, if the platform has applet
management enabled, then the platform is ready to execute applet management
commands. However, if there is a use-case that needs to shutdown, then the API
or scheduler will be extended to provide this functionality.</p>
<p>Use Ctrl-C to terminate the runner. For hardware boards, you can just remove the
power or let it run. The device is in sleep state (although if USB is enabled,
then it wakes up every millisecond to keep the connection active).</p>
<h2 id="on-board"><a class="header" href="#on-board">On board</a></h2>
<p>We currently only support the nRF52840-dk board from Nordic. If you have such a
dev board, you can run an applet (here the <code>tutorial</code> applet) on the <code>nordic</code>
runner with the following command:</p>
<pre><code class="language-shell">cargo xtask applet rust tutorial runner nordic
</code></pre>
<p>After a bunch of compilation steps, you should see something that ends like:</p>
<pre><code class="language-plaintext">&quot;.../wrapper.sh&quot; &quot;probe-rs&quot; &quot;run&quot; &quot;--chip=nRF52840_xxAA&quot; &quot;target/.../runner-nordic&quot;
     Erasing sectors [00:00:05] [################################]
 Programming pages   [00:00:04] [################################]
0.090527: hello world
</code></pre>
<p>The first line is from <code>cargo xtask</code>. The rest is from <code>probe-rs run</code>. The last
line is triggered by the applet. Debugging output is prefixed by a timestamp in
seconds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<p>The applet API is documented <a href="https://docs.rs/wasefire-applet-api">here</a>.</p>
<p>Note that you probably don't want to use the API directly, but instead want to
use the prelude of your programming language. The API is low-level and
corresponds to the interface at WebAssembly level.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prelude-1"><a class="header" href="#prelude-1">Prelude</a></h1>
<p>This chapter illustrates how to use some parts of the prelude.</p>
<p>The prelude documentation is available <a href="https://docs.rs/wasefire">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leds"><a class="header" href="#leds">LEDs</a></h1>
<p>In this section, we will walk through the <code>blink</code> example in Rust. It will blink
in order each LED of the board every second in an infinite loop (going back to
the first LED after the last LED).</p>
<p>The number of LEDs available on the board is advertised by the <code>led::count()</code>
function. We want to make sure there is at least one LED available:</p>
<pre><code class="language-rust no_run noplayground">    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, &quot;Board has no LEDs.&quot;);</code></pre>
<p>We start the infinite loop cycling through all LEDs in order:</p>
<pre><code class="language-rust no_run noplayground">    // Cycle indefinitely through all LEDs in order.
    for led_index in (0 .. num_leds).cycle() {</code></pre>
<p>Within the infinite loop (notice the indentation), we first turn on the current
LED using the <code>led::set()</code> function:</p>
<pre><code class="language-rust no_run noplayground">        // Turn on the current LED.
        led::set(led_index, led::On);</code></pre>
<p>We now wait for half a second because we want to blink each LED for one second
which means half a second on and half a second off:</p>
<pre><code class="language-rust no_run noplayground">        // Wait before turning it off.
        timer::sleep(Duration::from_millis(500));</code></pre>
<p>Finally, we repeat the same process but turning the LED off before looping to
the next LED:</p>
<pre><code class="language-rust no_run noplayground">        // Turn it off and wait before turning on the next LED.
        led::set(led_index, led::Off);
        timer::sleep(Duration::from_millis(500));</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use core::time::Duration;

fn main() {
    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, &quot;Board has no LEDs.&quot;);

    // Cycle indefinitely through all LEDs in order.
    for led_index in (0 .. num_leds).cycle() {
        // Turn on the current LED.
        led::set(led_index, led::On);
        // Wait before turning it off.
        timer::sleep(Duration::from_millis(500));

        // Turn it off and wait before turning on the next LED.
        led::set(led_index, led::Off);
        timer::sleep(Duration::from_millis(500));
    }
}</code></pre></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The <code>host</code> runner currently has 1 LED and prints its state on <code>stdout</code> as an
info-level log. Eventually, the number of LEDs will be configurable and how they
are represented will be improved (for example through some graphical interface).</p>
<p>To test the applet on the <code>host</code> runner, you'll thus need to use:</p>
<pre><code class="language-shell">cargo xtask applet rust blink runner host --log=info
</code></pre>
<p>The <code>--log=info</code> flag specifies that we want info-level (or more severe)
logging. By default, only errors are printed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buttons"><a class="header" href="#buttons">Buttons</a></h1>
<p>In this section, we will walk through 2 Rust examples:</p>
<ul>
<li>The <code>button</code> example illustrates stateless usage but lets us introduce how to
handle events with callbacks.</li>
<li>The <code>led</code> example illustrates stateful usage and thus how to access state in
callbacks.</li>
</ul>
<h2 id="stateless-usage"><a class="header" href="#stateless-usage">Stateless usage</a></h2>
<p>This example prints to the debug output the new state of a button each time that
button changed state and so for all buttons.</p>
<p>Similarly to LEDs, there is a <code>button::count()</code> function to discover the number
of buttons available on the board:</p>
<pre><code class="language-rust no_run noplayground">    // Make sure there is at least one button.
    let count = button::count();
    assert!(count &gt; 0, &quot;Board has no buttons.&quot;);</code></pre>
<p>We want to listen on events for all available buttons, so we loop over all
button indices (starting at 0):</p>
<pre><code class="language-rust no_run noplayground">    // For each button on the board.
    for index in 0 .. count {</code></pre>
<p>For each button, we define a handler that prints the new button state to the
debug output. The handler takes the new button state as argument. Since
<code>button::State</code> implements <code>Debug</code>, we simply use <code>{state:?}</code> to print the new
state.</p>
<pre><code class="language-rust no_run noplayground">        // We define a button handler printing the new state.
        let handler = move |state| debug!(&quot;Button {index} has been {state:?}.&quot;);</code></pre>
<p>We can now start listening for events. This is done by creating a
<code>button::Listener</code> which will call the provided handler each time the button
changes state. We specify the button we want to listen to by its index and the
handler as a closure.</p>
<pre><code class="language-rust no_run noplayground">        // We start listening for state changes with the handler.
        let listener = button::Listener::new(index, handler)?;</code></pre>
<p>A listener continues to listen for events until it is dropped. Since we want to
indefinitely listen, we must not drop the listener. A simple way to do that is
to leak it. This is equivalent to calling <code>core::mem::forget()</code>.</p>
<pre><code class="language-rust no_run noplayground">        // We leak the listener to continue listening for events.
        listener.leak();</code></pre>
<p>Finally, we just endlessly wait for callbacks. This step is optional: waiting
for callbacks indefinitely is the implicit behavior when <code>main</code> exits. In some
way, <code>main</code> can be seen as a callback setup procedure. The
<code>scheduling::wait_for_callback()</code> function puts the applet to sleep until a
callback is scheduled and <code>scheduled::wait_indefinitely()</code> is just an infinite
loop around <code>wait_for_callback()</code>.</p>
<pre><code class="language-rust no_run noplayground">    // We indefinitely wait for callbacks.
    scheduling::wait_indefinitely();</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

fn main() -&gt; Result&lt;(), Error&gt; {
    // Make sure there is at least one button.
    let count = button::count();
    assert!(count &gt; 0, &quot;Board has no buttons.&quot;);

    // For each button on the board.
    for index in 0 .. count {
        // We define a button handler printing the new state.
        let handler = move |state| debug!(&quot;Button {index} has been {state:?}.&quot;);

        // We start listening for state changes with the handler.
        let listener = button::Listener::new(index, handler)?;

        // We leak the listener to continue listening for events.
        listener.leak();
    }

    // We indefinitely wait for callbacks.
    scheduling::wait_indefinitely();
}</code></pre></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>The <code>host</code> runner currently has 1 button and is controlled by typing <code>button</code> on
a line on <code>stdin</code>. Eventually, the number of buttons will be configurable and
how they are controlled will be improved (for example through some graphical
interface).</p>
<h2 id="stateful-usage"><a class="header" href="#stateful-usage">Stateful usage</a></h2>
<p>This example combines all the LEDs and buttons available on the board by
maintaining a dynamic mapping between them. Initially, all buttons map to the
first LED. Each time a button is pressed or released, the LED it is mapped to is
toggled. And when a button is released, it maps to the next LED (or the first
one if it was mapping to the last one).</p>
<p>In particular:</p>
<ul>
<li>A single button can toggle all LEDs.</li>
<li>Multiple buttons can toggle the same LED.</li>
<li>A button may stay pressed while another button is pressed.</li>
<li>All buttons eventually toggle all LEDs.</li>
</ul>
<p>We skip over the setup which doesn't illustrate anything new:</p>
<pre><code class="language-rust no_run noplayground">    // Make sure there is at least one button.
    let num_buttons = button::count();
    assert!(num_buttons &gt; 0, &quot;Board has no buttons.&quot;);

    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, &quot;Board has no LEDs.&quot;);

    // For each button on the board.
    for button_index in 0 .. num_buttons {</code></pre>
<p>Because buttons dynamically map to a LED, we need a state to store this
information. We create this state on the heap because we will eventually leak
the listener and exit the <code>main</code> function to indefinitely listen for button
events. This state simply contains the index of the LED to which this buttons
maps to. We have to use <code>Cell</code> because the handler is called as <code>&amp;self</code> (and
thus closures must be <code>Fn</code> not <code>FnMut</code>)<sup class="footnote-reference"><a href="#cell">1</a></sup>.</p>
<pre><code class="language-rust no_run noplayground">        // We create the state containing the LED to which this button maps to.
        let led_pointer = Box::new(Cell::new(0));</code></pre>
<p>When defining the button handler, we must move (and thus transfer ownership of)
the state we just created to the handler, such that the handler can read and
write the state when called.</p>
<pre><code class="language-rust no_run noplayground">        // We define the button handler and move the state to there.
        let handler = move |button_state| {</code></pre>
<p>When the handler is called, we first toggle the associated LED:</p>
<pre><code class="language-rust no_run noplayground">            // We toggle the LED.
            let led_index = led_pointer.get();
            led::set(led_index, !led::get(led_index));</code></pre>
<p>And then if the button is released, we update the dynamic mapping to point to
the next LED (wrapping if needed):</p>
<pre><code class="language-rust no_run noplayground">            // If the button is released, we point it to the next LED.
            if matches!(button_state, button::Released) {
                led_pointer.set((led_index + 1) % num_leds);
            }</code></pre>
<p>Finally, we create a button listener with the defined handler. And we leak it to
continue listening after it going out of scope and in particular after <code>main</code>
returns.</p>
<pre><code class="language-rust no_run noplayground">        // We indefinitely listen by creating and leaking a listener.
        button::Listener::new(button_index, handler)?.leak();</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::boxed::Box;
use core::cell::Cell;

fn main() -&gt; Result&lt;(), Error&gt; {
    // Make sure there is at least one button.
    let num_buttons = button::count();
    assert!(num_buttons &gt; 0, &quot;Board has no buttons.&quot;);

    // Make sure there is at least one LED.
    let num_leds = led::count();
    assert!(num_leds &gt; 0, &quot;Board has no LEDs.&quot;);

    // For each button on the board.
    for button_index in 0 .. num_buttons {
        // We create the state containing the LED to which this button maps to.
        let led_pointer = Box::new(Cell::new(0));

        // We define the button handler and move the state to there.
        let handler = move |button_state| {
            // We toggle the LED.
            let led_index = led_pointer.get();
            led::set(led_index, !led::get(led_index));

            // If the button is released, we point it to the next LED.
            if matches!(button_state, button::Released) {
                led_pointer.set((led_index + 1) % num_leds);
            }
        };

        // We indefinitely listen by creating and leaking a listener.
        button::Listener::new(button_index, handler)?.leak();
    }

    Ok(())
}</code></pre></pre>
<div class="footnote-definition" id="cell"><sup class="footnote-definition-label">1</sup>
<p>This is because the handler could wait for callbacks itself (which the
prelude has no way to know, or is there?) and thus the handler may be
reentered. This would essentially copy a mutable reference which is unsound.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers"><a class="header" href="#timers">Timers</a></h1>
<p>In this section, we will walk through the <code>button_abort</code> example in Rust. It
uses the first button and the first LED of the board. On a short press, the LED
will start blinking. On a long press, the LED will stop blinking. While the
button is pressed, the LED indicates whether the press is short or long:</p>
<ul>
<li>The LED is on while the press is short.</li>
<li>The LED turns off once the press is long.</li>
</ul>
<p>This applet will need a shared state to know whether the LED must be blinking or
not. We cannot simply use a boolean because the state will be shared. We cannot
use <code>Cell&lt;bool&gt;</code> neither because the state must be in the heap<sup class="footnote-reference"><a href="#heap">1</a></sup>. So we use
<code>Rc&lt;Cell&lt;bool&gt;&gt;</code> which is a common pattern when using callbacks:</p>
<pre><code class="language-rust no_run noplayground">    // We define a shared state to decide whether we must blink.
    let blinking = Rc::new(Cell::new(false));</code></pre>
<p>We can now allocate a timer for the blinking behavior using <code>timer::Timer::new</code>.
This function takes the handler that will be called each time the timer fires.
The handler simply toggles the LED if we must be blinking. Note how we must move
a clone of the state to the callback. This is also a common pattern when using
callbacks, because callbacks must be <code>'static</code><sup class="footnote-reference"><a href="#heap">1</a></sup>:</p>
<pre><code class="language-rust no_run noplayground">    // Allocate a timer for blinking the LED.
    let blink = timer::Timer::new({
        // Move a clone of the state to the callback.
        let blinking = blinking.clone();
        move || {
            // Toggle the LED if blinking.
            if blinking.get() {
                led::set(0, !led::get(0));
            }
        }
    });</code></pre>
<p>The rest of the code is done in an infinite loop:</p>
<pre><code class="language-rust no_run noplayground">    loop {</code></pre>
<p>At each iteration, we start by setting up a <code>button::Listener</code> to record whether
the button was pressed and then released. The logic is similar to the callback
setup for the timer. The small difference is that we won't need to call any
function on the listener so we prefix its variable name <code>_button</code> with an
underscore. We cannot simply omit the variable name because we don't want to
drop it until the end of the loop iteration, otherwise we would stop listening
to button events.</p>
<pre><code class="language-rust no_run noplayground">        // Setup button listeners.
        let pressed = Rc::new(Cell::new(false));
        let released = Rc::new(Cell::new(false));
        let _button = button::Listener::new(0, {
            let pressed = pressed.clone();
            let released = released.clone();
            move |state| match state {
                button::Pressed =&gt; pressed.set(true),
                button::Released if pressed.get() =&gt; released.set(true),
                button::Released =&gt; (),
            }
        })?;</code></pre>
<p>We then wait until the button is pressed using <code>scheduling::wait_until()</code>. This
function takes a condition as argument and only executes callbacks until the
condition is satisfied.</p>
<pre><code class="language-rust no_run noplayground">        // Wait for the button to be pressed.
        scheduling::wait_until(|| pressed.get());</code></pre>
<p>According to the specification of this example applet, when the button is
pressed we must turn on the LED (and stop blinking if we were blinking) to
signal a possible short press. Note that callbacks can only executed when a
scheduling function is called, so we are essentially in a critical section. As
such, the order in which we do those 3 lines doesn't matter. However, a callback
might be scheduled before we stop the <code>blink</code> timer. It will execute next time
we call a scheduling function. This is ok because when that will happen, the
<code>blinking</code> state will be <code>false</code> and the <code>blink</code> handler will do nothing.</p>
<pre><code class="language-rust no_run noplayground">        // Turn the LED on.
        blink.stop();
        blinking.set(false);
        led::set(0, led::On);</code></pre>
<p>To detect a long press, we need to start a timer. There is nothing new here
except the <code>Timer::start()</code> function which takes the timer mode (one-shot or
periodic) and its duration.</p>
<pre><code class="language-rust no_run noplayground">        // Start the timeout to decide between short and long press.
        let timed_out = Rc::new(Cell::new(false));
        let timer = timer::Timer::new({
            let timed_out = timed_out.clone();
            move || timed_out.set(true)
        });
        timer.start(timer::Oneshot, Duration::from_secs(1));</code></pre>
<p>We now wait for the first event between the button being released and the
timeout firing. This is simply done by using a condition which is a disjunction
of the events of interest. This is a common pattern when implementing behavior
with a timeout.</p>
<pre><code class="language-rust no_run noplayground">        // Wait for the button to be released or the timeout to fire.
        scheduling::wait_until(|| released.get() || timed_out.get());</code></pre>
<p>To signal that the timeout was reached or the button was released, we turn off
the LED.</p>
<pre><code class="language-rust no_run noplayground">        // Turn the LED off.
        led::set(0, led::Off);</code></pre>
<p>Finally, if the press was short (i.e. the button was released before the
timeout), we start blinking. This demonstrates the use of periodic timers.</p>
<pre><code class="language-rust no_run noplayground">        // Start blinking if short press.
        if !timed_out.get() {
            blinking.set(true);
            blink.start(timer::Periodic, Duration::from_millis(200));
        }</code></pre>
<p>There are a few things to note:</p>
<ul>
<li>The code is implicit in Rust, but the button handler and the timer handler
within the loop iteration are dropped before the next iteration. This means
that their callbacks are unregistered. This could be done explicitly by
calling <code>core::mem::drop()</code> on their variable if needed.</li>
<li>It is not needed to start and stop the <code>blink</code> timer within the loop as long
as it is started before entering the loop. This is just an optimization to
avoid calling the handler when we know that the <code>blinking</code> shared state is
<code>false</code>, because the handler would do nothing in that case.</li>
</ul>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::rc::Rc;
use core::cell::Cell;
use core::time::Duration;

fn main() -&gt; Result&lt;(), Error&gt; {
    assert!(button::count() &gt; 0, &quot;Board has no buttons.&quot;);
    assert!(led::count() &gt; 0, &quot;Board has no LEDs.&quot;);

    // We define a shared state to decide whether we must blink.
    let blinking = Rc::new(Cell::new(false));

    // Allocate a timer for blinking the LED.
    let blink = timer::Timer::new({
        // Move a clone of the state to the callback.
        let blinking = blinking.clone();
        move || {
            // Toggle the LED if blinking.
            if blinking.get() {
                led::set(0, !led::get(0));
            }
        }
    });

    loop {
        // Setup button listeners.
        let pressed = Rc::new(Cell::new(false));
        let released = Rc::new(Cell::new(false));
        let _button = button::Listener::new(0, {
            let pressed = pressed.clone();
            let released = released.clone();
            move |state| match state {
                button::Pressed =&gt; pressed.set(true),
                button::Released if pressed.get() =&gt; released.set(true),
                button::Released =&gt; (),
            }
        })?;

        // Wait for the button to be pressed.
        scheduling::wait_until(|| pressed.get());

        // Turn the LED on.
        blink.stop();
        blinking.set(false);
        led::set(0, led::On);

        // Start the timeout to decide between short and long press.
        let timed_out = Rc::new(Cell::new(false));
        let timer = timer::Timer::new({
            let timed_out = timed_out.clone();
            move || timed_out.set(true)
        });
        timer.start(timer::Oneshot, Duration::from_secs(1));

        // Wait for the button to be released or the timeout to fire.
        scheduling::wait_until(|| released.get() || timed_out.get());

        // Turn the LED off.
        led::set(0, led::Off);

        // Start blinking if short press.
        if !timed_out.get() {
            blinking.set(true);
            blink.start(timer::Periodic, Duration::from_millis(200));
        }
    }
}</code></pre></pre>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<p>As for the LEDs and buttons examples, to test the applet on the <code>host</code> runner,
you'll need to use:</p>
<pre><code class="language-shell">cargo xtask applet rust button_abort runner host --log=info
</code></pre>
<p>However, in addition to <code>button</code> which does a press and release sequence, you
can use <code>press</code> and <code>release</code> to independently press and release the button. In
particular, <code>button</code> may be used to start blinking and <code>press</code> may be used to
stop blinking. There's no need to explicitly release because the applet supports
missing callbacks for robustness.</p>
<div class="footnote-definition" id="heap"><sup class="footnote-definition-label">1</sup>
<p>If the state were on the stack and a callback were pointing to that
state, it would become a safety requirement to unregister the callback
before popping the state from the stack. However, it is safe to leak a
callback with <code>core::mem::forget()</code> and thus not drop it. So we enforce
callbacks to be <code>'static</code> and thus not depend on references to the stack.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usb"><a class="header" href="#usb">USB</a></h1>
<p>For now only USB serial is supported. Eventually, the idea would be for applets
to describe the USB interfaces they need in some init function. The scheduler
would then create the USB device based on those information. And only then start
the applets with capabilities to the interfaces they asked for.</p>
<p>In this section, we will illustrate USB serial usage by walking through the
<code>memory_game</code> example. The game is essentially an infinite loop of memory
questions. The player has 3 seconds to memorize a random base32 string (the
length is the current level in the game and thus represents the difficulty). The
player than has 7 seconds to type it back. On success they go to the next level,
otherwise to the previous level.</p>
<p>The applet has only 2 states across loop iterations:</p>
<ul>
<li>The level of the game (and thus the length of the string to remember) starting
at 3.</li>
<li>The next prompt to show to the player while they get ready for the next
question.</li>
</ul>
<pre><code class="language-rust no_run noplayground">    let mut level = 3; // length of the string to remember
    let mut prompt = &quot;Press ENTER when you are ready.&quot;;</code></pre>
<p>Everything else is in the infinite loop:</p>
<pre><code class="language-rust no_run noplayground">    loop {</code></pre>
<p>First thing we do is print the prompt and wait for the player to press Enter. We
use ANSI escape codes to overwrite whatever was there before. As an invariant
throughout the game, we always use a single line of the terminal. This is
particularly important to overwrite the question since the player has to guess
it. We write to the USB serial using <code>serial::write_all()</code>. This function is
generic over objects implementing <code>serial::Serial</code>, in this case
<code>usb::serial::UsbSerial</code>.</p>
<pre><code class="language-rust no_run noplayground">        serial::write_all(&amp;UsbSerial, format!(&quot;\r\x1b[K{prompt}&quot;).as_bytes()).unwrap();</code></pre>
<p>We then wait until the player press Enter. We can read a single byte from the
USB serial using <code>serial::read_byte()</code>. The terminal sends <code>0x0d</code> when
Enter is pressed.</p>
<pre><code class="language-rust no_run noplayground">        // Make sure the player is ready.
        while serial::read_byte(&amp;UsbSerial).unwrap() != 0x0d {}</code></pre>
<p>To generate the next question, we use <code>rng::fill_bytes()</code> which fills a buffer
with random bytes. We provide a buffer with the length of the current level. For
the string to be printable we truncate the entropy of each byte from 8 to 5 bits
and convert it to a <code>base32</code> symbol.</p>
<pre><code class="language-rust no_run noplayground">        // Generate a question for this level.
        let mut question = vec![0; level];
        rng::fill_bytes(&amp;mut question).unwrap();
        for byte in &amp;mut question {
            const BASE32: [u8; 32] = *b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;;
            *byte = BASE32[(*byte &amp; 0x1f) as usize];
        }
        let mut question = String::from_utf8(question).unwrap();</code></pre>
<p>We can now show the question to the player. We do so using a <code>process</code> helper
function that we will also use for the answer. We instantiate this function such
that the player has 3 seconds to memorize the question and may hit Enter at any
time to start answering.</p>
<pre><code class="language-rust no_run noplayground">        // Display the question.
        process(3, &quot;Memorize this&quot;, &amp;mut question, |_, x| x == 0x0d);</code></pre>
<p>After 3 seconds have elapsed or if the player hit Enter, we read the answer from
the player. We give them 7 seconds to type the answer. We also convert
lower-case letters to upper-case for convenience (it's easier to read upper-case
but easier to type lower-case). We also support backspace which the terminal
sends as <code>0x7f</code>. And same as for the question, we let the player exit early with
Enter to avoid waiting until the timeout.</p>
<pre><code class="language-rust no_run noplayground">        // Read the answer.
        let mut answer = String::new();
        process(7, &quot;Type what you remember&quot;, &amp;mut answer, |answer, byte| {
            match byte {
                b'A' ..= b'Z' | b'2' ..= b'7' =&gt; answer.push(byte as char),
                b'a' ..= b'z' =&gt; answer.push(byte.to_ascii_uppercase() as char),
                0x7f =&gt; drop(answer.pop()),
                0x0d =&gt; return true,
                _ =&gt; (),
            }
            false
        });</code></pre>
<p>Once we have the answer, we check if it matches the question. If it does, we
promote the player to the next level. If it doesn't, we demote the player to the
previous level. However, if there are no previous level because the player is at
level 1, then we let them retry the level to show our support. We use ANSI
escape codes to highlight the result.</p>
<pre><code class="language-rust no_run noplayground">        // Check the answer.
        if answer == question {
            level += 1;
            prompt = &quot;\x1b[1;32mPromotion!\x1b[m Press ENTER for next level.&quot;;
        } else if level &gt; 1 {
            level -= 1;
            prompt = &quot;\x1b[1;31mDemotion...\x1b[m Press ENTER for previous level.&quot;;
        } else {
            prompt = &quot;\x1b[1;41mRetry?\x1b[m Press ENTER to retry.&quot;;
        }</code></pre>
<p>Now that we're done with the main loop, let's look at the <code>process</code> helper. It
takes 4 arguments:</p>
<ul>
<li><code>max_secs: usize</code>: the maximum display time in seconds.</li>
<li><code>prompt: &amp;str</code>: the message shown at the beginning of the line.</li>
<li><code>data: &amp;mut String</code>: the data shown after the prompt, which may be updated
(see below).</li>
<li><code>update: impl Fn(&amp;mut String, u8) -&gt; bool</code>: the closure called on each input
byte possibly updating the data and returning whether processing should end
immediately without waiting for the maximum display time.</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn process(
    max_secs: usize, prompt: &amp;str, data: &amp;mut String, update: impl Fn(&amp;mut String, u8) -&gt; bool,
) {</code></pre>
<p>The helper counts the number of elapsed seconds in shared variable <code>secs</code> and
updates it using a periodic timer every second.</p>
<pre><code class="language-rust no_run noplayground">    let secs = Rc::new(Cell::new(0));
    let timer = timer::Timer::new({
        let time = secs.clone();
        move || time.set(time.get() + 1)
    });
    timer.start(timer::Periodic, Duration::from_secs(1));</code></pre>
<p>The helper loops as long as the update function didn't say to stop (tracked by
the <code>done</code> variable) and there is still time available.</p>
<pre><code class="language-rust no_run noplayground">    let mut done = false;
    while !done &amp;&amp; secs.get() &lt; max_secs {</code></pre>
<p>We update the line in the terminal with the prompt, time left, and current data.
We use ANSI escape codes to highlight the data and help readability.</p>
<pre><code class="language-rust no_run noplayground">        let secs = max_secs - secs.get();
        let message = format!(&quot;\r\x1b[K{prompt} ({secs} seconds remaining): \x1b[1m{data}\x1b[m&quot;);
        serial::write_all(&amp;UsbSerial, message.as_bytes()).unwrap();</code></pre>
<p>To be able to update the time left in the terminal we must read from the USB
serial asynchronously using <code>serial::Reader</code>. We create a reader by providing a
mutable buffer to which the reader will write the received bytes.</p>
<pre><code class="language-rust no_run noplayground">        let mut buffer = [0; 8];
        let reader = serial::Reader::new(&amp;UsbSerial, &amp;mut buffer);</code></pre>
<p>We then sleep until a callback is executed using
<code>scheduling::wait_for_callback()</code>. This callback may either be the timer firing
the next second or the reader getting input from the USB serial.</p>
<pre><code class="language-rust no_run noplayground">        scheduling::wait_for_callback();</code></pre>
<p>We call <code>Reader::result()</code> to know how many bytes were read from USB serial and
written to the buffer (or if an error occurred). We then simply iterate over the
received bytes and update the data and early exit status according to the
provided closure. Same as with timers, when a reader is dropped, its callback is
canceled.</p>
<pre><code class="language-rust no_run noplayground">        let len = reader.result().unwrap();
        for &amp;byte in &amp;buffer[.. len] {
            done |= update(data, byte);
        }</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::rc::Rc;
use alloc::string::String;
use alloc::{format, vec};
use core::cell::Cell;
use core::time::Duration;

use wasefire::usb::serial::UsbSerial;

fn main() {
    let mut level = 3; // length of the string to remember
    let mut prompt = &quot;Press ENTER when you are ready.&quot;;
    loop {
        serial::write_all(&amp;UsbSerial, format!(&quot;\r\x1b[K{prompt}&quot;).as_bytes()).unwrap();

        // Make sure the player is ready.
        while serial::read_byte(&amp;UsbSerial).unwrap() != 0x0d {}

        // Generate a question for this level.
        let mut question = vec![0; level];
        rng::fill_bytes(&amp;mut question).unwrap();
        for byte in &amp;mut question {
            const BASE32: [u8; 32] = *b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;;
            *byte = BASE32[(*byte &amp; 0x1f) as usize];
        }
        let mut question = String::from_utf8(question).unwrap();

        // Display the question.
        process(3, &quot;Memorize this&quot;, &amp;mut question, |_, x| x == 0x0d);

        // Read the answer.
        let mut answer = String::new();
        process(7, &quot;Type what you remember&quot;, &amp;mut answer, |answer, byte| {
            match byte {
                b'A' ..= b'Z' | b'2' ..= b'7' =&gt; answer.push(byte as char),
                b'a' ..= b'z' =&gt; answer.push(byte.to_ascii_uppercase() as char),
                0x7f =&gt; drop(answer.pop()),
                0x0d =&gt; return true,
                _ =&gt; (),
            }
            false
        });

        // Check the answer.
        if answer == question {
            level += 1;
            prompt = &quot;\x1b[1;32mPromotion!\x1b[m Press ENTER for next level.&quot;;
        } else if level &gt; 1 {
            level -= 1;
            prompt = &quot;\x1b[1;31mDemotion...\x1b[m Press ENTER for previous level.&quot;;
        } else {
            prompt = &quot;\x1b[1;41mRetry?\x1b[m Press ENTER to retry.&quot;;
        }
    }
}

fn process(
    max_secs: usize, prompt: &amp;str, data: &amp;mut String, update: impl Fn(&amp;mut String, u8) -&gt; bool,
) {
    let secs = Rc::new(Cell::new(0));
    let timer = timer::Timer::new({
        let time = secs.clone();
        move || time.set(time.get() + 1)
    });
    timer.start(timer::Periodic, Duration::from_secs(1));
    let mut done = false;
    while !done &amp;&amp; secs.get() &lt; max_secs {
        let secs = max_secs - secs.get();
        let message = format!(&quot;\r\x1b[K{prompt} ({secs} seconds remaining): \x1b[1m{data}\x1b[m&quot;);
        serial::write_all(&amp;UsbSerial, message.as_bytes()).unwrap();
        let mut buffer = [0; 8];
        let reader = serial::Reader::new(&amp;UsbSerial, &amp;mut buffer);
        scheduling::wait_for_callback();
        let len = reader.result().unwrap();
        for &amp;byte in &amp;buffer[.. len] {
            done |= update(data, byte);
        }
    }
}</code></pre></pre>
<p>You can connect to the USB serial with the following command:</p>
<pre><code class="language-shell">picocom -q /dev/ttyACM1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart"><a class="header" href="#uart">UART</a></h1>
<p>Using the UART is similar to using the USB serial, because the
<code>uart::Uart::new(uart_id)</code> object implements <code>serial::Serial</code>, where <code>uart_id</code>
is the UART id. The <code>uart::count()</code> function returns how many UARTs are
available on the device. UART ids must be smaller than this count.</p>
<p>It is usually a good idea to write generic code over any serial without assuming
a particular implementation. This can be done by using a <code>serial</code> variable
implementing <code>serial::Serial</code>. This variable may be instantiated differently
based on a compilation feature:</p>
<pre><code class="language-rust no_run noplayground">#[cfg(feature = &quot;serial_uart&quot;)]
let serial = uart::Uart::new(0).unwrap();
#[cfg(feature = &quot;serial_usb&quot;)]
let serial = usb::serial::UsbSerial;
// ...
serial::write_all(&amp;serial, b&quot;hello&quot;).unwrap();</code></pre>
<p>When using the host runner, you can connect to the UART with:</p>
<pre><code class="language-shell">socat -,cfmakeraw UNIX-CONNECT:target/wasefire/uart0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>For now only a key-value store is supported for persistent storage. Eventually,
additional facilities may be added: a cyclic logging journal, a file-system,
raw flash access, etc.</p>
<p>In this section, we will illustrate the key-value store usage by walking through
the <code>store</code> example which provides direct store access through USB serial.</p>
<p>We first define a helper to write a line to the USB serial.</p>
<pre><code class="language-rust no_run noplayground">fn writeln(buf: &amp;[u8]) {
    serial::write_all(&amp;UsbSerial, buf).unwrap();
    serial::write_all(&amp;UsbSerial, b&quot;\r\n&quot;).unwrap();
}</code></pre>
<p>Because values may be at most 1023 bytes, there is a system to store large
entries as multiple fragments of at most 1023 bytes each using multiple keys. To
support those large entries, we define an abstract notion of keys. An abstract
key is either exactly one key, or a contiguous range of keys.</p>
<pre><code class="language-rust no_run noplayground">enum Key {
    Exact(usize),
    Range(Range&lt;usize&gt;),
}</code></pre>
<p>We then define helpers to dispatch to the regular or fragmented version based on
the abstract key. The <code>insert</code>, <code>find</code>, and <code>remove</code> functions will be explained
later.</p>
<pre><code class="language-rust no_run noplayground">fn insert(key: &amp;Key, value: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::insert(*key, value),
        Key::Range(keys) =&gt; store::fragment::insert(keys.clone(), value),
    }
}

fn find(key: &amp;Key) -&gt; Result&lt;Option&lt;Box&lt;[u8]&gt;&gt;, Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::find(*key),
        Key::Range(keys) =&gt; store::fragment::find(keys.clone()),
    }
}

fn remove(key: &amp;Key) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::remove(*key),
        Key::Range(keys) =&gt; store::fragment::remove(keys.clone()),
    }
}</code></pre>
<p>The first thing we do when the applet starts is print a short help describing
how to use the applet.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    writeln(b&quot;Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;&quot;);
    writeln(b&quot;Usage: find &lt;key&gt;[..&lt;key&gt;]&quot;);
    writeln(b&quot;Usage: remove &lt;key&gt;[..&lt;key&gt;]&quot;);</code></pre>
<p>We can then start the infinite loop processing exactly one command per
iteration.</p>
<pre><code class="language-rust no_run noplayground">    loop {</code></pre>
<p>We start a loop iteration by reading a command from the user. Only space,
lower-case alphabetic characters, digits, and backspace are supported. We exit
as soon as the user hits Enter.</p>
<pre><code class="language-rust no_run noplayground">        // Read the command.
        let mut command = String::new();
        loop {
            serial::write_all(&amp;UsbSerial, format!(&quot;\r\x1b[K&gt; {command}&quot;).as_bytes()).unwrap();
            match serial::read_byte(&amp;UsbSerial).unwrap() {
                c @ (b' ' | b'.' | b'a' ..= b'z' | b'0' ..= b'9') =&gt; command.push(c as char),
                0x7f =&gt; drop(command.pop()),
                0x0d =&gt; break,
                _ =&gt; (),
            }
        }
        serial::write_all(&amp;UsbSerial, b&quot;\r\n&quot;).unwrap();</code></pre>
<p>We then parse the command (described later). If the command is invalid, we print
a message and continue to the next loop iteration.</p>
<pre><code class="language-rust no_run noplayground">        // Parse the command.
        let command = match Command::parse(&amp;command) {
            Some(x) =&gt; x,
            None =&gt; {
                writeln(b&quot;Failed: InvalidCommand&quot;);
                continue;
            }
        };</code></pre>
<p>And we finally process the command (described later). If processing failed, we
print a message with the error. Regardless of error, this is the end of the loop
(and thus the main function) and we continue to the next iteration.</p>
<pre><code class="language-rust no_run noplayground">        // Process the command.
        if let Err(error) = command.process() {
            writeln(format!(&quot;Failed: {error:?}&quot;).as_bytes());
        }</code></pre>
<p>To ease parsing and processing, we define a straightforward type for commands.</p>
<pre><code class="language-rust no_run noplayground">enum Command&lt;'a&gt; {
    Insert { key: Key, value: &amp;'a str },
    Find { key: Key },
    Remove { key: Key },
}</code></pre>
<p>The parsing function is also straightforward.</p>
<pre><code class="language-rust no_run noplayground">impl&lt;'a&gt; Command&lt;'a&gt; {
    fn parse(input: &amp;'a str) -&gt; Option&lt;Self&gt; {
        Some(match *input.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [&quot;insert&quot;, key, value] =&gt; Command::Insert { key: Key::parse(key)?, value },
            [&quot;find&quot;, key] =&gt; Command::Find { key: Key::parse(key)? },
            [&quot;remove&quot;, key] =&gt; Command::Remove { key: Key::parse(key)? },
            _ =&gt; return None,
        })
    }</code></pre>
<p>The process function is a <code>Command</code> method which may return a store error.</p>
<pre><code class="language-rust no_run noplayground">    fn process(&amp;self) -&gt; Result&lt;(), Error&gt; {</code></pre>
<p>For insert commands, we simply forward to the <code>store::insert()</code> function (resp.
<code>store::fragment::insert()</code> for fragmented entries) which maps a key (resp. a
range of keys) to a value. If the key (resp. range of keys) was already mapped,
it is overwritten. A key must be a number smaller than 4096. A range of keys
must be non-empty. A value must be a slice of at most 1023 bytes (resp. 1023
bytes times the number of fragments).</p>
<pre><code class="language-rust no_run noplayground">        match self {
            Command::Insert { key, value } =&gt; insert(key, value.as_bytes()),</code></pre>
<p>Remove commands are also straightforward. We use <code>store::remove()</code> which maps a
key to nothing. It's not an error if the key wasn't mapped before.</p>
<pre><code class="language-rust no_run noplayground">            Command::Remove { key } =&gt; remove(key),</code></pre>
<p>Finally, find commands are implemented using <code>store::find()</code> which takes a key
and return the mapped value if any.</p>
<pre><code class="language-rust no_run noplayground">            Command::Find { key } =&gt; {
                match find(key)? {</code></pre>
<p>We print a message if no value was found.</p>
<pre><code class="language-rust no_run noplayground">                    None =&gt; writeln(b&quot;Not found.&quot;),</code></pre>
<p>Otherwise, we try to convert the byte slice to a string slice. This should
succeed for values that were inserted by this applet since we only accept
alphanumeric characters. In that case, we simply print the value.</p>
<pre><code class="language-rust no_run noplayground">                    Some(value) =&gt; match core::str::from_utf8(&amp;value) {
                        Ok(value) =&gt; writeln(format!(&quot;Found: {value}&quot;).as_bytes()),</code></pre>
<p>However, because the store is persistent and keys are not yet partitioned by
applets, we could read the values written by a previous applet for that key. And
those values don't need to be valid UTF-8. In those cases, we print the value as
a byte slice.</p>
<pre><code class="language-rust no_run noplayground">                        Err(_) =&gt; writeln(format!(&quot;Found (not UTF-8): {value:02x?}&quot;).as_bytes()),</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::boxed::Box;
use alloc::format;
use alloc::string::String;
use alloc::vec::Vec;
use core::num::ParseIntError;
use core::ops::Range;
use core::str::FromStr;

use wasefire::usb::serial::UsbSerial;

fn main() {
    writeln(b&quot;Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;&quot;);
    writeln(b&quot;Usage: find &lt;key&gt;[..&lt;key&gt;]&quot;);
    writeln(b&quot;Usage: remove &lt;key&gt;[..&lt;key&gt;]&quot;);
    loop {
        // Read the command.
        let mut command = String::new();
        loop {
            serial::write_all(&amp;UsbSerial, format!(&quot;\r\x1b[K&gt; {command}&quot;).as_bytes()).unwrap();
            match serial::read_byte(&amp;UsbSerial).unwrap() {
                c @ (b' ' | b'.' | b'a' ..= b'z' | b'0' ..= b'9') =&gt; command.push(c as char),
                0x7f =&gt; drop(command.pop()),
                0x0d =&gt; break,
                _ =&gt; (),
            }
        }
        serial::write_all(&amp;UsbSerial, b&quot;\r\n&quot;).unwrap();

        // Parse the command.
        let command = match Command::parse(&amp;command) {
            Some(x) =&gt; x,
            None =&gt; {
                writeln(b&quot;Failed: InvalidCommand&quot;);
                continue;
            }
        };

        // Process the command.
        if let Err(error) = command.process() {
            writeln(format!(&quot;Failed: {error:?}&quot;).as_bytes());
        }
    }
}

enum Command&lt;'a&gt; {
    Insert { key: Key, value: &amp;'a str },
    Find { key: Key },
    Remove { key: Key },
}

impl&lt;'a&gt; Command&lt;'a&gt; {
    fn parse(input: &amp;'a str) -&gt; Option&lt;Self&gt; {
        Some(match *input.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [&quot;insert&quot;, key, value] =&gt; Command::Insert { key: Key::parse(key)?, value },
            [&quot;find&quot;, key] =&gt; Command::Find { key: Key::parse(key)? },
            [&quot;remove&quot;, key] =&gt; Command::Remove { key: Key::parse(key)? },
            _ =&gt; return None,
        })
    }

    fn process(&amp;self) -&gt; Result&lt;(), Error&gt; {
        match self {
            Command::Insert { key, value } =&gt; insert(key, value.as_bytes()),
            Command::Find { key } =&gt; {
                match find(key)? {
                    None =&gt; writeln(b&quot;Not found.&quot;),
                    Some(value) =&gt; match core::str::from_utf8(&amp;value) {
                        Ok(value) =&gt; writeln(format!(&quot;Found: {value}&quot;).as_bytes()),
                        Err(_) =&gt; writeln(format!(&quot;Found (not UTF-8): {value:02x?}&quot;).as_bytes()),
                    },
                }
                Ok(())
            }
            Command::Remove { key } =&gt; remove(key),
        }
    }
}

enum Key {
    Exact(usize),
    Range(Range&lt;usize&gt;),
}

impl FromStr for Key {
    type Err = ParseIntError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.split_once(&quot;..&quot;) {
            Some((start, end)) =&gt; Ok(Key::Range(start.parse()? .. end.parse()?)),
            None =&gt; Ok(Key::Exact(s.parse()?)),
        }
    }
}

impl Key {
    fn parse(key: &amp;str) -&gt; Option&lt;Self&gt; {
        let key: Key = key.parse().ok()?;
        let valid = match &amp;key {
            Key::Exact(key) =&gt; *key &lt; 4096,
            Key::Range(keys) =&gt; !keys.is_empty() &amp;&amp; keys.end &lt; 4096,
        };
        if !valid {
            return None;
        }
        Some(key)
    }
}

fn insert(key: &amp;Key, value: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::insert(*key, value),
        Key::Range(keys) =&gt; store::fragment::insert(keys.clone(), value),
    }
}

fn find(key: &amp;Key) -&gt; Result&lt;Option&lt;Box&lt;[u8]&gt;&gt;, Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::find(*key),
        Key::Range(keys) =&gt; store::fragment::find(keys.clone()),
    }
}

fn remove(key: &amp;Key) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::remove(*key),
        Key::Range(keys) =&gt; store::fragment::remove(keys.clone()),
    }
}

fn writeln(buf: &amp;[u8]) {
    serial::write_all(&amp;UsbSerial, buf).unwrap();
    serial::write_all(&amp;UsbSerial, b&quot;\r\n&quot;).unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>The
<a href="https://github.com/google/wasefire/tree/main/examples/rust/exercises"><code>examples/rust/exercises</code></a>
contains exercises to implement an applet that behaves like a security key over
UART.</p>
<p>The <code>part-&lt;n&gt;</code> directories contain the successive parts towards the final
applet. You will need to modify those applets by fixing the different <code>TODO</code>
comments. The exercise description is at the top of the <code>src/lib.rs</code> file.</p>
<p>The <code>part-&lt;n&gt;-sol</code> directories contain the solution for each part. You don't
need to modify those applets. You can look at them for hints while working
<code>part-&lt;n&gt;</code>.</p>
<p>The <code>client</code> directory contains a binary to communicate with the applet. You
don't need to modify this binary. You can use it by running <code>cargo run</code> in that
directory. In particular you can get help with <code>cargo run -- help</code> and run send
specific requests to the applet with <code>cargo run -- register foo</code> for example.</p>
<p>The <code>interface</code> directory contains a library defining the interface between the
applet and the client. You don't need to modify this library but you need to
read its documentation. You will use it from the applet.</p>
<p>You can run an applet on the host runner with:</p>
<pre><code class="language-shell">cargo xtask applet rust exercises/part-1 runner host --web
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>There are a few <a href="https://github.com/google/wasefire/tree/main/examples/rust">existing
applets</a> that
demonstrate simple usage of the prelude and should cover all functionalities in
the prelude. Each example starts with a short documentation in its <code>src/lib.rs</code>
file.</p>
<p>Noticeable examples are:</p>
<ul>
<li><code>hsm</code> implements some simple HSM-like API using the <code>crypto</code>, <code>store</code>, and
<code>usb::serial</code> modules of the prelude. It comes with a companion program to
interact with the applet (see the documentation in the <code>src/lib.rs</code> of the
applet).</li>
<li><code>ctap</code> implements some simple CTAP-like API using the <code>button</code>, <code>led</code>,
<code>timer</code>,<code>scheduling</code>, <code>store</code>, and <code>usb::serial</code> modules of the prelude. It
describes its usage when connecting to the USB serial interface.</li>
<li><code>memory_game</code> implements some memory game using the <code>usb::serial</code> module of
the prelude. It describes its usage when connecting to the USB serial
interface.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runner-user-guide"><a class="header" href="#runner-user-guide">Runner user guide</a></h1>
<p>This chapter will describe how you can add support for a board. It is not yet
written though and only provides a link to the API to implement.</p>
<p>There's currently only 2 supported boards:</p>
<ul>
<li><code>nordic</code> for nRF52840-dk</li>
<li><code>host</code> for Linux (not clear if more or less is actually supported)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-1"><a class="header" href="#api-1">API</a></h1>
<p>The board API is documented <a href="https://docs.rs/wasefire-board-api">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h1>
<p>This section tries to answer common questions. If your question is not listed
here, please open an <a href="https://github.com/google/wasefire/issues/new">issue</a>.</p>
<h3 id="are-applets-trusted-to-be-correct"><a class="header" href="#are-applets-trusted-to-be-correct">Are applets trusted to be correct?</a></h3>
<p>No. The platform does not trust applets and applets do not trust each other.
However, if an applet has a valid signature, then the platform trusts the
permissions required by the applet.</p>
<h3 id="are-applets-executed-as-native-code"><a class="header" href="#are-applets-executed-as-native-code">Are applets executed as native code?</a></h3>
<p>No. Applets are installed as WebAssembly byte-code. This is required since the
static guarantees provided by WebAssembly apply to the byte-code and the
platform checks those guarantees. For execution, applets are interpreted: either
directly from the byte-code, or for performance purposes from an optimized
representation in flash or RAM which may be computed ahead-of-time or on-demand.</p>
<h3 id="why-is-performance-not-an-issue"><a class="header" href="#why-is-performance-not-an-issue">Why is performance not an issue?</a></h3>
<p>The main bets are:</p>
<ul>
<li>Computing intensive code (like cryptography) is done in hardware or native
code (in the platform).</li>
<li>Applets are supposed to only do business logic which is assumed to not be
computing intensive.</li>
<li>The platform targets users who can't write embedded code, so the main concern
is not performance but making firmware development accessible.</li>
</ul>
<h3 id="how-does-this-fit-on-micro-controllers"><a class="header" href="#how-does-this-fit-on-micro-controllers">How does this fit on micro-controllers?</a></h3>
<p>The interpreter currently fits in 22kB when optimized for size and 66kB when
optimized for speed. The interpreter is also designed to have minimal RAM
overhead. However, most optimizations (for both performance and overhead) are
not yet implemented, which may increase the binary size.</p>
<h3 id="why-implement-a-new-interpreter"><a class="header" href="#why-implement-a-new-interpreter">Why implement a new interpreter?</a></h3>
<p>The following runtimes have been quickly rejected:</p>
<ul>
<li><code>wasmtime</code> and <code>wasmer</code> don't support no-std</li>
<li><code>wasmi</code> consumes too much RAM for embedded</li>
</ul>
<p><code>wasm3</code> has been used during the initial phase of the project but got eventually
replaced with a custom interpreter for the following reasons:</p>
<ul>
<li>It doesn't perform validation
<a href="https://github.com/wasm3/wasm3/issues/344">yet</a>. We probably need proper
validation.</li>
<li>It only compiles to RAM (not flash). We want to be able to preprocess a module
and persist the pre-computation in flash such that it is only done when a
module is installed and not each time it is instantiated.</li>
<li>It takes control of the execution flow. All runtimes I'm aware of behave like
that. To simplify scheduling, we want the interpreter to give back control
when asked or when a host function is called.</li>
<li>It is written in C. Although the code has tests and fuzzing, we want
additional security provided by the language.</li>
</ul>
<p>The interpreter we implemented is written in Rust, doesn't take control of the
execution thread, doesn't pre-compute anything yet (but will be able to
pre-compute to flash), and performs validation.</p>
<h3 id="applet-footprint-compared-to-native-code"><a class="header" href="#applet-footprint-compared-to-native-code">Applet footprint compared to native code?</a></h3>
<p>WebAssembly byte-code is compact so there should be a footprint benefit compared
to native code. However, no benchmarks have been done in that regard.</p>
<h3 id="is-it-possible-to-share-code-between-applets"><a class="header" href="#is-it-possible-to-share-code-between-applets">Is it possible to share code between applets?</a></h3>
<p>Yes (although not yet implemented). Applets are represented at runtime by a
WebAssembly store which is unique per applet. Applets behavior is defined by a
set of WebAssembly modules which are instantiated to the applet store. Applets
may share those modules. A typical example would be an allocator module.
Multiple applets may use the same allocator byte-code (from the module) to
manage their own linear memory (from the module instance in the applet store).</p>
<h3 id="what-third-party-dependencies-are-used"><a class="header" href="#what-third-party-dependencies-are-used">What third-party dependencies are used?</a></h3>
<p>The minimum set of third-party dependencies is currently:</p>
<ul>
<li><code>num_enum</code> for the interpreter</li>
<li><code>usb-device</code> and <code>usbd-serial</code> for the board API</li>
</ul>
<p>Additional dependencies are used by:</p>
<ul>
<li>the actual board implementation:
<ul>
<li>(e.g. <code>cortex-m-rt</code>, <code>nrf52840-hal</code>, <code>panic-abort</code> for nordic)</li>
<li>(e.g. <code>tokio</code>, <code>usbip-device</code>, <code>aes</code>, <code>rand</code> for linux)</li>
</ul>
</li>
<li>compilation (e.g. <code>proc-macro2</code>, <code>quote</code>)</li>
<li>debugging (e.g. <code>defmt</code>, <code>defmt-rtt</code>, <code>log</code>, <code>env_logger</code>)</li>
<li>tooling (e.g. <code>anyhow</code>, <code>clap</code>)</li>
</ul>
<p>In particular, the project doesn't need any operating system (e.g. TockOS) but
may use one as part of a board implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="links"><a class="header" href="#links">Links</a></h1>
<h2 id="project"><a class="header" href="#project">Project</a></h2>
<ul>
<li>Website: <a href="https://google.github.io/wasefire">https://google.github.io/wasefire</a></li>
<li>Github: <a href="https://github.com/google/wasefire">https://github.com/google/wasefire</a></li>
<li>Mailing list: <a href="https://groups.google.com/g/wasefire">https://groups.google.com/g/wasefire</a></li>
</ul>
<h2 id="presentations"><a class="header" href="#presentations">Presentations</a></h2>
<ul>
<li>Hardwear.io NL 2023 workshop
<a href="https://github.com/google/wasefire/blob/main/docs/presentations/2023-Hardwear.io-NL-workshop.pdf">slides</a></li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<ul>
<li>The <a href="https://google.github.io/wasefire/faq.html">FAQ</a> of this document</li>
<li>Rust prelude: <a href="https://docs.rs/wasefire">https://docs.rs/wasefire</a></li>
<li>Board API: <a href="https://docs.rs/wasefire-board-api">https://docs.rs/wasefire-board-api</a></li>
<li>Applet API: <a href="https://docs.rs/wasefire-applet-api">https://docs.rs/wasefire-applet-api</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h1>
<p>This project would not be where it is now if it couldn't build upon the
following projects<sup class="footnote-reference"><a href="#exhaustiveness">1</a></sup>:</p>
<div class="table-wrapper"><table><thead><tr><th>Project</th><th>Author</th><th>Usage</th></tr></thead><tbody>
<tr><td><a href="https://github.com/knurling-rs/defmt">defmt</a></td><td><a href="https://github.com/knurling-rs">Knurling</a></td><td>Logging for embedded</td></tr>
<tr><td><a href="https://github.com/knurling-rs/probe-run">probe-run</a></td><td><a href="https://github.com/knurling-rs">Knurling</a></td><td>(now replaced by probe-rs)</td></tr>
<tr><td><a href="https://github.com/probe-rs/probe-rs">probe-rs</a></td><td><a href="https://github.com/probe-rs">probe.rs</a></td><td>Flashing and debugging</td></tr>
<tr><td><a href="https://github.com/rust-embedded/cortex-m">cortex-m</a></td><td><a href="https://github.com/rust-embedded">Rust Embedded</a></td><td>Cortex-M support</td></tr>
<tr><td><a href="https://github.com/rust-embedded/riscv">riscv</a></td><td><a href="https://github.com/rust-embedded">Rust Embedded</a></td><td>RISC-V support</td></tr>
<tr><td><a href="https://github.com/rust-embedded/critical-section">critical-section</a></td><td><a href="https://github.com/rust-embedded">Rust Embedded</a></td><td>Mutex support</td></tr>
<tr><td><a href="https://github.com/taiki-e/portable-atomic">portable-atomic</a></td><td><a href="https://github.com/taiki-e">taiki-e</a></td><td>Atomic support</td></tr>
<tr><td><a href="https://github.com/rust-embedded-community/usb-device">usb-device</a></td><td><a href="https://github.com/rust-embedded-community">Rust Embedded Community</a></td><td>Generic USB interface</td></tr>
<tr><td><a href="https://github.com/rust-embedded-community/usbd-serial">usbd-serial</a></td><td><a href="https://github.com/rust-embedded-community">Rust Embedded Community</a></td><td>USB serial implementation</td></tr>
<tr><td><a href="https://github.com/Sawchord/usbip-device">usbip-device</a></td><td><a href="https://github.com/Sawchord">Sawchord</a></td><td>USB/IP implementation</td></tr>
<tr><td><a href="https://github.com/nrf-rs/nrf-hal">nrf-hal</a></td><td><a href="https://github.com/nrf-rs">nRF Rust</a></td><td>nRF52840 support</td></tr>
<tr><td><a href="https://github.com/nrf-rs/nrf-usbd">nrf-usbd</a></td><td><a href="https://github.com/nrf-rs">nRF Rust</a></td><td>nRF52840 USB implementation</td></tr>
<tr><td><a href="https://github.com/RustCrypto/hashes">hashes</a></td><td><a href="https://github.com/RustCrypto">Rust Crypto</a></td><td>SHA-256 and 384</td></tr>
<tr><td><a href="https://github.com/RustCrypto/MACs">MACs</a></td><td><a href="https://github.com/RustCrypto">Rust Crypto</a></td><td>HMAC-SHA-256 and 384</td></tr>
<tr><td><a href="https://github.com/RustCrypto/AEADs">AEADs</a></td><td><a href="https://github.com/RustCrypto">Rust Crypto</a></td><td>AES-128-CCM and 256-GCM</td></tr>
<tr><td><a href="https://github.com/RustCrypto/elliptic-curves">elliptic-curves</a></td><td><a href="https://github.com/RustCrypto">Rust Crypto</a></td><td>NIST P-256 and 384</td></tr>
<tr><td><a href="https://github.com/rust-lang/rust-analyzer">rust-analyzer</a></td><td><a href="https://github.com/rust-lang">Rust</a></td><td>Rust development</td></tr>
<tr><td><a href="https://github.com/wasm3/wasm3">wasm3</a></td><td><a href="https://github.com/wasm3">Wasm3 Labs</a></td><td>(not used anymore)</td></tr>
</tbody></table>
</div>
<p>We would like to thank all authors and contributors of those projects (as well
as those we use but we forgot to mention) and more generally the community
around Rust for embedded development. We are also grateful to those who answered
our issues [<a href="https://github.com/probe-rs/probe-rs/issues/1865">1</a>, <a href="https://github.com/rust-embedded/critical-section/issues/42">2</a>, <a href="https://github.com/probe-rs/probe-rs/issues/1863">3</a>, <a href="https://github.com/probe-rs/probe-rs/issues/1816">4</a>, <a href="https://github.com/knurling-rs/probe-run/issues/421">5</a>, <a href="https://github.com/RustCrypto/traits/issues/1311">6</a>, <a href="https://github.com/RustCrypto/KDFs/issues/80">7</a>, <a href="https://github.com/RustCrypto/traits/issues/1307">8</a>, <a href="https://github.com/knurling-rs/defmt/issues/738">9</a>] and reviewed our pull
requests [<a href="https://github.com/probe-rs/probe-rs/pull/1919">10</a>, <a href="https://github.com/nrf-rs/nrf-usbd/pull/17">11</a>, <a href="https://github.com/Sawchord/usbip-device/pull/5">12</a>, <a href="https://github.com/rust-embedded-community/usb-device/pull/115">13</a>].</p>
<div class="footnote-definition" id="exhaustiveness"><sup class="footnote-definition-label">1</sup>
<p>We tried to focus on the projects that were critical to get
where we are now. Some projects are thus deliberately left out (and some
projects that we don't use anymore are still listed). But it is also
possible that we forgot to list some, in which case we apologize and would
be happy to fix our oversight if notified.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
