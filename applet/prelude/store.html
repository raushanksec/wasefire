<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Storage - Wasefire</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../../overview/index.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../overview/terminology.html"><strong aria-hidden="true">1.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="../../overview/features.html"><strong aria-hidden="true">1.2.</strong> Features</a></li></ol></li><li class="chapter-item expanded "><a href="../../quick/index.html"><strong aria-hidden="true">2.</strong> Quick start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../quick/codespace.html"><strong aria-hidden="true">2.1.</strong> Github codespace tips</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/index.html"><strong aria-hidden="true">3.</strong> Applet user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/create.html"><strong aria-hidden="true">3.1.</strong> Create a new applet</a></li><li class="chapter-item expanded "><a href="../../applet/run.html"><strong aria-hidden="true">3.2.</strong> Run an applet</a></li><li class="chapter-item expanded "><a href="../../applet/api.html"><strong aria-hidden="true">3.3.</strong> API</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/index.html"><strong aria-hidden="true">3.4.</strong> Prelude</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../applet/prelude/led.html"><strong aria-hidden="true">3.4.1.</strong> LEDs</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/button.html"><strong aria-hidden="true">3.4.2.</strong> Buttons</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/timer.html"><strong aria-hidden="true">3.4.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/usb.html"><strong aria-hidden="true">3.4.4.</strong> USB</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/uart.html"><strong aria-hidden="true">3.4.5.</strong> UART</a></li><li class="chapter-item expanded "><a href="../../applet/prelude/store.html" class="active"><strong aria-hidden="true">3.4.6.</strong> Storage</a></li></ol></li><li class="chapter-item expanded "><a href="../../applet/exercises/index.html"><strong aria-hidden="true">3.5.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../../applet/examples.html"><strong aria-hidden="true">3.6.</strong> Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../../runner/index.html"><strong aria-hidden="true">4.</strong> Runner user guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runner/api.html"><strong aria-hidden="true">4.1.</strong> API</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Developer guide</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Design</div></li></ol></li><li class="chapter-item expanded "><a href="../../faq.html">FAQ</a></li><li class="chapter-item expanded affix "><a href="../../links.html">Links</a></li><li class="chapter-item expanded affix "><a href="../../acknowledgments.html">Acknowledgments</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wasefire</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/google/wasefire/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>For now only a key-value store is supported for persistent storage. Eventually,
additional facilities may be added: a cyclic logging journal, a file-system,
raw flash access, etc.</p>
<p>In this section, we will illustrate the key-value store usage by walking through
the <code>store</code> example which provides direct store access through USB serial.</p>
<p>We first define a helper to write a line to the USB serial.</p>
<pre><code class="language-rust no_run noplayground">fn writeln(buf: &amp;[u8]) {
    serial::write_all(&amp;UsbSerial, buf).unwrap();
    serial::write_all(&amp;UsbSerial, b&quot;\r\n&quot;).unwrap();
}</code></pre>
<p>Because values may be at most 1023 bytes, there is a system to store large
entries as multiple fragments of at most 1023 bytes each using multiple keys. To
support those large entries, we define an abstract notion of keys. An abstract
key is either exactly one key, or a contiguous range of keys.</p>
<pre><code class="language-rust no_run noplayground">enum Key {
    Exact(usize),
    Range(Range&lt;usize&gt;),
}</code></pre>
<p>We then define helpers to dispatch to the regular or fragmented version based on
the abstract key. The <code>insert</code>, <code>find</code>, and <code>remove</code> functions will be explained
later.</p>
<pre><code class="language-rust no_run noplayground">fn insert(key: &amp;Key, value: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::insert(*key, value),
        Key::Range(keys) =&gt; store::fragment::insert(keys.clone(), value),
    }
}

fn find(key: &amp;Key) -&gt; Result&lt;Option&lt;Box&lt;[u8]&gt;&gt;, Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::find(*key),
        Key::Range(keys) =&gt; store::fragment::find(keys.clone()),
    }
}

fn remove(key: &amp;Key) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::remove(*key),
        Key::Range(keys) =&gt; store::fragment::remove(keys.clone()),
    }
}</code></pre>
<p>The first thing we do when the applet starts is print a short help describing
how to use the applet.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    writeln(b&quot;Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;&quot;);
    writeln(b&quot;Usage: find &lt;key&gt;[..&lt;key&gt;]&quot;);
    writeln(b&quot;Usage: remove &lt;key&gt;[..&lt;key&gt;]&quot;);</code></pre>
<p>We can then start the infinite loop processing exactly one command per
iteration.</p>
<pre><code class="language-rust no_run noplayground">    loop {</code></pre>
<p>We start a loop iteration by reading a command from the user. Only space,
lower-case alphabetic characters, digits, and backspace are supported. We exit
as soon as the user hits Enter.</p>
<pre><code class="language-rust no_run noplayground">        // Read the command.
        let mut command = String::new();
        loop {
            serial::write_all(&amp;UsbSerial, format!(&quot;\r\x1b[K&gt; {command}&quot;).as_bytes()).unwrap();
            match serial::read_byte(&amp;UsbSerial).unwrap() {
                c @ (b' ' | b'.' | b'a' ..= b'z' | b'0' ..= b'9') =&gt; command.push(c as char),
                0x7f =&gt; drop(command.pop()),
                0x0d =&gt; break,
                _ =&gt; (),
            }
        }
        serial::write_all(&amp;UsbSerial, b&quot;\r\n&quot;).unwrap();</code></pre>
<p>We then parse the command (described later). If the command is invalid, we print
a message and continue to the next loop iteration.</p>
<pre><code class="language-rust no_run noplayground">        // Parse the command.
        let command = match Command::parse(&amp;command) {
            Some(x) =&gt; x,
            None =&gt; {
                writeln(b&quot;Failed: InvalidCommand&quot;);
                continue;
            }
        };</code></pre>
<p>And we finally process the command (described later). If processing failed, we
print a message with the error. Regardless of error, this is the end of the loop
(and thus the main function) and we continue to the next iteration.</p>
<pre><code class="language-rust no_run noplayground">        // Process the command.
        if let Err(error) = command.process() {
            writeln(format!(&quot;Failed: {error:?}&quot;).as_bytes());
        }</code></pre>
<p>To ease parsing and processing, we define a straightforward type for commands.</p>
<pre><code class="language-rust no_run noplayground">enum Command&lt;'a&gt; {
    Insert { key: Key, value: &amp;'a str },
    Find { key: Key },
    Remove { key: Key },
}</code></pre>
<p>The parsing function is also straightforward.</p>
<pre><code class="language-rust no_run noplayground">impl&lt;'a&gt; Command&lt;'a&gt; {
    fn parse(input: &amp;'a str) -&gt; Option&lt;Self&gt; {
        Some(match *input.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [&quot;insert&quot;, key, value] =&gt; Command::Insert { key: Key::parse(key)?, value },
            [&quot;find&quot;, key] =&gt; Command::Find { key: Key::parse(key)? },
            [&quot;remove&quot;, key] =&gt; Command::Remove { key: Key::parse(key)? },
            _ =&gt; return None,
        })
    }</code></pre>
<p>The process function is a <code>Command</code> method which may return a store error.</p>
<pre><code class="language-rust no_run noplayground">    fn process(&amp;self) -&gt; Result&lt;(), Error&gt; {</code></pre>
<p>For insert commands, we simply forward to the <code>store::insert()</code> function (resp.
<code>store::fragment::insert()</code> for fragmented entries) which maps a key (resp. a
range of keys) to a value. If the key (resp. range of keys) was already mapped,
it is overwritten. A key must be a number smaller than 4096. A range of keys
must be non-empty. A value must be a slice of at most 1023 bytes (resp. 1023
bytes times the number of fragments).</p>
<pre><code class="language-rust no_run noplayground">        match self {
            Command::Insert { key, value } =&gt; insert(key, value.as_bytes()),</code></pre>
<p>Remove commands are also straightforward. We use <code>store::remove()</code> which maps a
key to nothing. It's not an error if the key wasn't mapped before.</p>
<pre><code class="language-rust no_run noplayground">            Command::Remove { key } =&gt; remove(key),</code></pre>
<p>Finally, find commands are implemented using <code>store::find()</code> which takes a key
and return the mapped value if any.</p>
<pre><code class="language-rust no_run noplayground">            Command::Find { key } =&gt; {
                match find(key)? {</code></pre>
<p>We print a message if no value was found.</p>
<pre><code class="language-rust no_run noplayground">                    None =&gt; writeln(b&quot;Not found.&quot;),</code></pre>
<p>Otherwise, we try to convert the byte slice to a string slice. This should
succeed for values that were inserted by this applet since we only accept
alphanumeric characters. In that case, we simply print the value.</p>
<pre><code class="language-rust no_run noplayground">                    Some(value) =&gt; match core::str::from_utf8(&amp;value) {
                        Ok(value) =&gt; writeln(format!(&quot;Found: {value}&quot;).as_bytes()),</code></pre>
<p>However, because the store is persistent and keys are not yet partitioned by
applets, we could read the values written by a previous applet for that key. And
those values don't need to be valid UTF-8. In those cases, we print the value as
a byte slice.</p>
<pre><code class="language-rust no_run noplayground">                        Err(_) =&gt; writeln(format!(&quot;Found (not UTF-8): {value:02x?}&quot;).as_bytes()),</code></pre>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">#![no_std]
wasefire::applet!();

use alloc::boxed::Box;
use alloc::format;
use alloc::string::String;
use alloc::vec::Vec;
use core::num::ParseIntError;
use core::ops::Range;
use core::str::FromStr;

use wasefire::usb::serial::UsbSerial;

fn main() {
    writeln(b&quot;Usage: insert &lt;key&gt;[..&lt;key&gt;] &lt;value&gt;&quot;);
    writeln(b&quot;Usage: find &lt;key&gt;[..&lt;key&gt;]&quot;);
    writeln(b&quot;Usage: remove &lt;key&gt;[..&lt;key&gt;]&quot;);
    loop {
        // Read the command.
        let mut command = String::new();
        loop {
            serial::write_all(&amp;UsbSerial, format!(&quot;\r\x1b[K&gt; {command}&quot;).as_bytes()).unwrap();
            match serial::read_byte(&amp;UsbSerial).unwrap() {
                c @ (b' ' | b'.' | b'a' ..= b'z' | b'0' ..= b'9') =&gt; command.push(c as char),
                0x7f =&gt; drop(command.pop()),
                0x0d =&gt; break,
                _ =&gt; (),
            }
        }
        serial::write_all(&amp;UsbSerial, b&quot;\r\n&quot;).unwrap();

        // Parse the command.
        let command = match Command::parse(&amp;command) {
            Some(x) =&gt; x,
            None =&gt; {
                writeln(b&quot;Failed: InvalidCommand&quot;);
                continue;
            }
        };

        // Process the command.
        if let Err(error) = command.process() {
            writeln(format!(&quot;Failed: {error:?}&quot;).as_bytes());
        }
    }
}

enum Command&lt;'a&gt; {
    Insert { key: Key, value: &amp;'a str },
    Find { key: Key },
    Remove { key: Key },
}

impl&lt;'a&gt; Command&lt;'a&gt; {
    fn parse(input: &amp;'a str) -&gt; Option&lt;Self&gt; {
        Some(match *input.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;().as_slice() {
            [&quot;insert&quot;, key, value] =&gt; Command::Insert { key: Key::parse(key)?, value },
            [&quot;find&quot;, key] =&gt; Command::Find { key: Key::parse(key)? },
            [&quot;remove&quot;, key] =&gt; Command::Remove { key: Key::parse(key)? },
            _ =&gt; return None,
        })
    }

    fn process(&amp;self) -&gt; Result&lt;(), Error&gt; {
        match self {
            Command::Insert { key, value } =&gt; insert(key, value.as_bytes()),
            Command::Find { key } =&gt; {
                match find(key)? {
                    None =&gt; writeln(b&quot;Not found.&quot;),
                    Some(value) =&gt; match core::str::from_utf8(&amp;value) {
                        Ok(value) =&gt; writeln(format!(&quot;Found: {value}&quot;).as_bytes()),
                        Err(_) =&gt; writeln(format!(&quot;Found (not UTF-8): {value:02x?}&quot;).as_bytes()),
                    },
                }
                Ok(())
            }
            Command::Remove { key } =&gt; remove(key),
        }
    }
}

enum Key {
    Exact(usize),
    Range(Range&lt;usize&gt;),
}

impl FromStr for Key {
    type Err = ParseIntError;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.split_once(&quot;..&quot;) {
            Some((start, end)) =&gt; Ok(Key::Range(start.parse()? .. end.parse()?)),
            None =&gt; Ok(Key::Exact(s.parse()?)),
        }
    }
}

impl Key {
    fn parse(key: &amp;str) -&gt; Option&lt;Self&gt; {
        let key: Key = key.parse().ok()?;
        let valid = match &amp;key {
            Key::Exact(key) =&gt; *key &lt; 4096,
            Key::Range(keys) =&gt; !keys.is_empty() &amp;&amp; keys.end &lt; 4096,
        };
        if !valid {
            return None;
        }
        Some(key)
    }
}

fn insert(key: &amp;Key, value: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::insert(*key, value),
        Key::Range(keys) =&gt; store::fragment::insert(keys.clone(), value),
    }
}

fn find(key: &amp;Key) -&gt; Result&lt;Option&lt;Box&lt;[u8]&gt;&gt;, Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::find(*key),
        Key::Range(keys) =&gt; store::fragment::find(keys.clone()),
    }
}

fn remove(key: &amp;Key) -&gt; Result&lt;(), Error&gt; {
    match key {
        Key::Exact(key) =&gt; store::remove(*key),
        Key::Range(keys) =&gt; store::fragment::remove(keys.clone()),
    }
}

fn writeln(buf: &amp;[u8]) {
    serial::write_all(&amp;UsbSerial, buf).unwrap();
    serial::write_all(&amp;UsbSerial, b&quot;\r\n&quot;).unwrap();
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../applet/prelude/uart.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../applet/exercises/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../applet/prelude/uart.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../applet/exercises/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
